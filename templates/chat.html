<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ character.name }} - AIè§’è‰²èŠå¤©</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .character-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
        }

        .call-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .call-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background: white;
            color: #333;
        }

        .call-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .call-btn.start-call {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .call-btn.end-call {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            display: none;
        }

        .call-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .call-status {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            color: #333;
            display: none;
            align-items: center;
            gap: 8px;
        }

        .call-status.active {
            display: flex;
        }

        .call-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.assistant {
            justify-content: flex-start;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.assistant .message-content {
            background: white;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .voice-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .voice-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            user-select: none;
        }

        .record-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            min-width: 140px;
        }

        .record-btn:hover:not(.recording):not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .record-btn.recording {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            animation: pulse 1s infinite;
            transform: scale(1.05);
        }

        .record-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .play-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            min-width: 100px;
        }

        .play-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }

        .play-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .activate-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            min-width: 120px;
            display: none;
        }

        .activate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
        }

        .voice-status {
            flex: 1;
            font-size: 14px;
            color: #666;
            margin-left: 10px;
            font-weight: 500;
        }

        .voice-status.recording {
            color: #f44336;
            font-weight: bold;
        }

        .voice-status.processing {
            color: #ff9800;
        }

        .voice-status.error {
            color: #f44336;
        }

        .voice-status.success {
            color: #4CAF50;
        }

        .voice-status.speaking {
            color: #2196F3;
            font-weight: bold;
        }

        .voice-settings {
            display: flex;
            gap: 15px;
            font-size: 12px;
            align-items: center;
        }

        .voice-settings label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            white-space: nowrap;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            outline: none;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            color: #666;
            font-style: italic;
        }

        .debug-info {
            font-size: 11px;
            color: #999;
            margin: 0 20px 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            border: 1px solid #dee2e6;
            max-height: 80px;
            overflow-y: auto;
        }

        .browser-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 12px;
            margin: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
        }

        .activation-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            margin: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }

        .call-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            display: none;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-100%); }
            to { transform: translateX(-50%) translateY(0); }
        }

        .voice-visualizer {
            height: 40px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 0 20px;
            margin: 10px 20px;
        }

        .voice-visualizer.active {
            display: flex;
        }

        .voice-bar {
            width: 4px;
            height: 20px;
            background: #667eea;
            border-radius: 2px;
            animation: wave 0.5s ease-in-out infinite;
        }

        .voice-bar:nth-child(2) { animation-delay: 0.1s; }
        .voice-bar:nth-child(3) { animation-delay: 0.2s; }
        .voice-bar:nth-child(4) { animation-delay: 0.3s; }
        .voice-bar:nth-child(5) { animation-delay: 0.4s; }

        @keyframes wave {
            0%, 100% { transform: scaleY(0.5); }
            50% { transform: scaleY(1.5); }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <!-- èŠå¤©å¤´éƒ¨ -->
        <div class="chat-header">
            <div class="character-info">
                <img src="{{ character.avatar }}" alt="{{ character.name }}" class="character-avatar">
                <div>
                    <h2 style="margin: 0;">{{ character.name }}</h2>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">{{ character.description }}</p>
                </div>
            </div>

            <!-- é€šè¯æ§åˆ¶æŒ‰é’® -->
            <div class="call-controls">
                <button id="startCallBtn" class="call-btn start-call" title="å¼€å§‹è¯­éŸ³é€šè¯">
                    ğŸ“ è¯­éŸ³é€šè¯
                </button>
                <button id="endCallBtn" class="call-btn end-call" title="ç»“æŸé€šè¯">
                    ğŸ“´ ç»“æŸé€šè¯
                </button>
            </div>

            <!-- é€šè¯çŠ¶æ€æ˜¾ç¤º -->
            <div id="callStatus" class="call-status">
                <span class="status-dot"></span>
                <span id="callStatusText">é€šè¯ä¸­</span>
                <span id="callDuration">00:00</span>
            </div>
        </div>

        <!-- é€šè¯é€šçŸ¥ -->
        <div id="callNotification" class="call-notification"></div>

        <!-- æµè§ˆå™¨å…¼å®¹æ€§æç¤º -->
        <div class="browser-info" id="browserInfo" style="display: none;">
        </div>

        <!-- æ¿€æ´»æç¤º -->
        <div class="activation-notice" id="activationNotice" style="display: none;">
            <strong>ğŸ”Š è¯­éŸ³åŠŸèƒ½éœ€è¦æ¿€æ´»</strong><br>
            è¯·ç‚¹å‡»ä¸‹æ–¹çš„"æ¿€æ´»è¯­éŸ³"æŒ‰é’®ä»¥å¯ç”¨è‡ªåŠ¨è¯­éŸ³å›å¤åŠŸèƒ½
        </div>

        <!-- è¯­éŸ³å¯è§†åŒ– -->
        <div class="voice-visualizer" id="voiceVisualizer">
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
            <div class="voice-bar"></div>
        </div>

        <!-- è¯­éŸ³æ§åˆ¶ -->
        <div class="voice-controls">
            <button id="activateBtn" class="voice-btn activate-btn">ğŸ”Š æ¿€æ´»è¯­éŸ³</button>
            <button id="recordBtn" class="voice-btn record-btn">ğŸ¤ é•¿æŒ‰è¯´è¯</button>
            <button id="playBtn" class="voice-btn play-btn" disabled>ğŸ”Š æ’­æ”¾</button>
            <div class="voice-status" id="voiceStatus">æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§...</div>
            <div class="voice-settings">
                <label>
                    <input type="checkbox" id="autoPlay" checked> è‡ªåŠ¨æ’­æ”¾
                </label>
                <label>
                    <input type="checkbox" id="voiceInput" checked> è¯­éŸ³è¾“å…¥
                </label>
                <select id="langSelect">
                    <option value="zh-CN">ä¸­æ–‡</option>
                    <option value="en-US">English</option>
                    <option value="ja-JP">æ—¥æœ¬èª</option>
                </select>
            </div>
        </div>

        <!-- è°ƒè¯•ä¿¡æ¯ -->
        <div class="debug-info" id="debugInfo"></div>

        <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ -->
        <div class="chat-messages" id="chatMessages">
            <!-- æ¶ˆæ¯å°†åœ¨è¿™é‡ŒåŠ¨æ€æ˜¾ç¤º -->
        </div>

        <div class="typing-indicator" id="typingIndicator">
            {{ character.name }} æ­£åœ¨è¾“å…¥...
        </div>

        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="chat-input">
            <div class="input-group">
                <input
                    type="text"
                    id="messageInput"
                    class="message-input"
                    placeholder="è¾“å…¥æ¶ˆæ¯æˆ–é•¿æŒ‰è¯­éŸ³æŒ‰é’®è¯´è¯..."
                    maxlength="2000"
                >
                <button id="sendBtn" class="send-btn">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const sessionId = '{{ session_id }}';
        const characterId = '{{ character.id }}';
        let voiceConfig = null;
        let lastResponse = '';
        let isRecording = false;
        let recognition = null;
        let synthesis = window.speechSynthesis;
        let recordingStartTime = 0;
        let mouseDownTimer = null;
        let voiceActivated = false;
        let currentUtterance = null;

        // WebSocketç›¸å…³
        let socket = null;
        let isInCall = false;
        let callStartTime = null;
        let callDurationTimer = null;
        let continuousRecognition = null;

        // DOMå…ƒç´ 
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const typingIndicator = document.getElementById('typingIndicator');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const activateBtn = document.getElementById('activateBtn');
        const voiceStatus = document.getElementById('voiceStatus');
        const autoPlay = document.getElementById('autoPlay');
        const voiceInput = document.getElementById('voiceInput');
        const langSelect = document.getElementById('langSelect');
        const debugInfo = document.getElementById('debugInfo');
        const browserInfo = document.getElementById('browserInfo');
        const activationNotice = document.getElementById('activationNotice');
        const startCallBtn = document.getElementById('startCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const callStatus = document.getElementById('callStatus');
        const callStatusText = document.getElementById('callStatusText');
        const callDuration = document.getElementById('callDuration');
        const callNotification = document.getElementById('callNotification');
        const voiceVisualizer = document.getElementById('voiceVisualizer');

        // åˆå§‹åŒ–WebSocket
        function initializeWebSocket() {
            socket = io();

            socket.on('connect', () => {
                updateDebug('WebSocketè¿æ¥æˆåŠŸ');
                updateDebug(`Socket ID: ${socket.id}`);
            });

            socket.on('disconnect', () => {
                updateDebug('WebSocketè¿æ¥æ–­å¼€');
                if (isInCall) {
                    endVoiceCall();
                }
            });

            socket.on('call_started', (data) => {
                updateDebug(`é€šè¯å·²å¼€å§‹ - Room: ${data.room}`);
                showCallNotification('è¯­éŸ³é€šè¯å·²è¿æ¥');
            });

            socket.on('call_ended', (data) => {
                updateDebug(`é€šè¯å·²ç»“æŸï¼Œæ—¶é•¿: ${data.duration}ç§’`);
                showCallNotification(`é€šè¯ç»“æŸï¼Œæ—¶é•¿: ${formatDuration(data.duration)}`);
                endVoiceCall();
            });

            socket.on('processing', (data) => {
                updateDebug('AIæ­£åœ¨æ€è€ƒ...');
                showTypingIndicator();
            });

            socket.on('user_transcript_confirmed', (data) => {
                updateDebug(`ç”¨æˆ·æ¶ˆæ¯å·²ç¡®è®¤: ${data.transcript}`);
                displayMessage('user', data.transcript);
            });

            socket.on('ai_response_chunk', (data) => {
                updateDebug(`æ”¶åˆ°AIå“åº”ç‰‡æ®µ: ${data.chunk}`);
                // å¯ä»¥åœ¨è¿™é‡Œå®ç°é€å­—æ˜¾ç¤ºæ•ˆæœ
            });

            socket.on('ai_response', (data) => {
                updateDebug(`æ”¶åˆ°å®Œæ•´AIå“åº”: ${data.text.substring(0, 50)}...`);
                hideTypingIndicator();

                // æ˜¾ç¤ºæ–‡å­—æ¶ˆæ¯
                displayMessage('assistant', data.text);
                lastResponse = data.text;

                // åœ¨é€šè¯ä¸­è‡ªåŠ¨æ’­æ”¾å“åº”
                if (isInCall && voiceActivated) {
                    updateDebug('é€šè¯ä¸­æ’­æ”¾AIå“åº”');
                    // ç›´æ¥æ’­æ”¾ï¼Œä¸åœæ­¢è¯­éŸ³è¯†åˆ«
                    speakText(data.text);
                } else {
                    updateDebug(`æœªæ’­æ”¾è¯­éŸ³ - isInCall: ${isInCall}, voiceActivated: ${voiceActivated}`);
                }
            });

            socket.on('ai_voice_config', (config) => {
                updateDebug('æ”¶åˆ°è¯­éŸ³é…ç½®');
                voiceConfig = config;
            });

            socket.on('voice_transcript', (data) => {
                updateDebug(`æ”¶åˆ°è½¬å½•åé¦ˆ: "${data.transcript}" (final: ${data.is_final})`);
            });

            socket.on('error', (data) => {
                updateDebug(`WebSocketé”™è¯¯: ${data.message}`);
                voiceStatus.textContent = `é”™è¯¯: ${data.message}`;
                voiceStatus.classList.add('error');
                showCallNotification(`é”™è¯¯: ${data.message}`);
            });

            // ç›‘å¬æ‰€æœ‰äº‹ä»¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
            socket.onAny((eventName, ...args) => {
                updateDebug(`æ”¶åˆ°äº‹ä»¶: ${eventName}`);
                console.log(`WebSocket Event: ${eventName}`, args);
            });
        }

        // ä¸“é—¨ç”¨äºé€šè¯æœŸé—´çš„è¯­éŸ³æ’­æ”¾
        function speakTextDuringCall(text) {
            updateDebug(`é€šè¯æœŸé—´æ’­æ”¾è¯­éŸ³: "${text.substring(0, 50)}..."`);

            // æ¸…é™¤ä¹‹å‰çš„æ‰€æœ‰è¯­éŸ³
            synthesis.cancel();

            // åˆ›å»ºæ–°çš„è¯­éŸ³
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langSelect.value;
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            utterance.onstart = function() {
                updateDebug('AIè¯­éŸ³æ’­æ”¾å¼€å§‹ï¼ˆé€šè¯æ¨¡å¼ï¼‰');
                voiceStatus.textContent = 'AIæ­£åœ¨è¯´è¯...';
                voiceStatus.classList.add('speaking');

                // æ˜¾ç¤ºå¯è§†åŒ–
                voiceVisualizer.classList.add('active');
            };

            utterance.onend = function() {
                updateDebug('AIè¯­éŸ³æ’­æ”¾ç»“æŸï¼Œé‡æ–°å¯åŠ¨è¯­éŸ³è¯†åˆ«');
                voiceStatus.textContent = 'æ­£åœ¨å¬å–...';
                voiceStatus.classList.remove('speaking');

                // å¦‚æœè¿˜åœ¨é€šè¯ä¸­ï¼Œé‡æ–°å¯åŠ¨è¯­éŸ³è¯†åˆ«
                if (isInCall) {
                    setTimeout(() => {
                        if (isInCall) {
                            updateDebug('é‡æ–°å¯åŠ¨è¿ç»­è¯­éŸ³è¯†åˆ«');
                            startContinuousRecognition();
                        }
                    }, 300); // çŸ­æš‚å»¶è¿Ÿé¿å…éŸ³é¢‘å†²çª
                }
            };

            utterance.onerror = function(event) {
                updateDebug(`è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`);
                voiceStatus.textContent = 'æ’­æ”¾å¤±è´¥';

                // å³ä½¿æ’­æ”¾å¤±è´¥ä¹Ÿè¦é‡å¯è¯†åˆ«
                if (isInCall) {
                    setTimeout(() => {
                        if (isInCall) {
                            startContinuousRecognition();
                        }
                    }, 300);
                }
            };

            // å¼€å§‹æ’­æ”¾
            try {
                synthesis.speak(utterance);
                updateDebug('è¯­éŸ³åˆæˆå‘½ä»¤å·²å‘é€');
            } catch (error) {
                updateDebug(`è¯­éŸ³æ’­æ”¾å¼‚å¸¸: ${error.message}`);
                // æ’­æ”¾å¤±è´¥ä¹Ÿè¦é‡å¯è¯†åˆ«
                if (isInCall) {
                    setTimeout(() => {
                        startContinuousRecognition();
                    }, 300);
                }
            }
        }

        // å¼€å§‹è¯­éŸ³é€šè¯
        function startVoiceCall() {
            if (!socket || !socket.connected) {
                showCallNotification('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å¼€å§‹é€šè¯');
                return;
            }

            if (!voiceActivated) {
                showCallNotification('è¯·å…ˆæ¿€æ´»è¯­éŸ³åŠŸèƒ½');
                activateBtn.click();
                return;
            }

            updateDebug('å¼€å§‹è¯­éŸ³é€šè¯');

            // é‡è¦ï¼šåœ¨é€šè¯å¼€å§‹æ—¶é‡æ–°æ¿€æ´»è¯­éŸ³åˆæˆ
            if (synthesis.speaking) {
                synthesis.cancel();
            }

            // åˆ›å»ºä¸€ä¸ªé™éŸ³çš„utteranceæ¥æ¿€æ´»éŸ³é¢‘ä¸Šä¸‹æ–‡
            const silentUtterance = new SpeechSynthesisUtterance('');
            silentUtterance.volume = 0;
            synthesis.speak(silentUtterance);

            socket.emit('start_voice_call', {
                session_id: sessionId,
                character_id: characterId
            });

            isInCall = true;
            callStartTime = new Date();

            // æ›´æ–°UI
            startCallBtn.style.display = 'none';
            endCallBtn.style.display = 'inline-block';
            callStatus.classList.add('active');
            voiceVisualizer.classList.add('active');

            // å¼€å§‹é€šè¯è®¡æ—¶
            startCallTimer();

            // å¼€å§‹è¿ç»­è¯­éŸ³è¯†åˆ«
            startContinuousRecognition();

            updateDebug(`é€šè¯çŠ¶æ€ - isInCall: ${isInCall}, voiceActivated: ${voiceActivated}`);
        }

        // ç»“æŸè¯­éŸ³é€šè¯
        function endVoiceCall() {
            if (!isInCall) return;

            updateDebug('ç»“æŸè¯­éŸ³é€šè¯');

            if (socket && socket.connected) {
                socket.emit('end_voice_call', {
                    session_id: sessionId
                });
            }

            isInCall = false;

            // åœæ­¢è®¡æ—¶å™¨
            if (callDurationTimer) {
                clearInterval(callDurationTimer);
                callDurationTimer = null;
            }

            // åœæ­¢è¯­éŸ³è¯†åˆ«
            if (continuousRecognition) {
                try {
                    continuousRecognition.stop();
                } catch (e) {}
            }

            // æ›´æ–°UI
            startCallBtn.style.display = 'inline-block';
            endCallBtn.style.display = 'none';
            callStatus.classList.remove('active');
            voiceVisualizer.classList.remove('active');
            callDuration.textContent = '00:00';
        }

        // å¼€å§‹é€šè¯è®¡æ—¶
        function startCallTimer() {
            callDurationTimer = setInterval(() => {
                if (callStartTime) {
                    const duration = Math.floor((new Date() - callStartTime) / 1000);
                    callDuration.textContent = formatDuration(duration);
                }
            }, 1000);
        }

        // æ ¼å¼åŒ–æ—¶é•¿
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // æ˜¾ç¤ºé€šè¯é€šçŸ¥
        function showCallNotification(message) {
            callNotification.textContent = message;
            callNotification.style.display = 'block';

            setTimeout(() => {
                callNotification.style.display = 'none';
            }, 3000);
        }

        // å¼€å§‹è¿ç»­è¯­éŸ³è¯†åˆ«ï¼ˆç”¨äºé€šè¯ï¼‰
        function startContinuousRecognition() {
            if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
                updateDebug('æµè§ˆå™¨ä¸æ”¯æŒè¿ç»­è¯­éŸ³è¯†åˆ«');
                return;
            }

            continuousRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            continuousRecognition.continuous = true;
            continuousRecognition.interimResults = true;
            continuousRecognition.lang = langSelect.value;
            continuousRecognition.maxAlternatives = 1;

            let finalTranscript = '';
            let lastTranscript = '';
            let silenceTimer = null;
            let speechStartTime = null;

            continuousRecognition.onresult = function(event) {
                let interimTranscript = '';
                let hasNewSpeech = false;

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;

                    if (transcript.trim().length > 0) {
                        hasNewSpeech = true;
                    }

                    if (event.results[i].isFinal) {
                        finalTranscript = transcript;

                        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ„ä¹‰çš„å†…å®¹
                        if (transcript.trim().length > 1 && transcript !== lastTranscript) {
                            lastTranscript = transcript;

                            // å‘é€æœ€ç»ˆè¯†åˆ«ç»“æœ
                            socket.emit('voice_stream', {
                                transcript: transcript,
                                is_final: true
                            });

                            updateDebug(`å‘é€æœ€ç»ˆè¯†åˆ«: "${transcript}"`);
                            speechStartTime = null;
                        }

                        finalTranscript = '';

                    } else {
                        interimTranscript += transcript;

                        if (!speechStartTime && transcript.trim().length > 0) {
                            speechStartTime = Date.now();
                        }

                        // å‘é€ä¸´æ—¶è¯†åˆ«ç»“æœ
                        socket.emit('voice_stream', {
                            transcript: interimTranscript,
                            is_final: false
                        });
                    }
                }

                // æ£€æµ‹åˆ°ç”¨æˆ·å¼€å§‹è¯´è¯ï¼Œç«‹å³åœæ­¢AIè¯­éŸ³æ’­æ”¾
                if (hasNewSpeech && synthesis.speaking) {
                    updateDebug('æ£€æµ‹åˆ°ç”¨æˆ·è¯´è¯ï¼Œåœæ­¢AIè¯­éŸ³æ’­æ”¾');
                    synthesis.cancel();
                    voiceStatus.textContent = 'æ­£åœ¨å¬å–...';
                    voiceStatus.classList.remove('speaking');
                }

                // é™éŸ³æ£€æµ‹
                if (silenceTimer) {
                    clearTimeout(silenceTimer);
                }

                silenceTimer = setTimeout(() => {
                    if (speechStartTime && Date.now() - speechStartTime > 1500) {
                        if (interimTranscript && interimTranscript.trim().length > 1) {
                            socket.emit('voice_stream', {
                                transcript: interimTranscript,
                                is_final: true
                            });
                            updateDebug(`é™éŸ³æ£€æµ‹ï¼Œå‘é€: "${interimTranscript}"`);
                        }
                    }
                    speechStartTime = null;
                }, 1500);

                // å¯è§†åŒ–åé¦ˆ
                if (interimTranscript || finalTranscript) {
                    voiceVisualizer.classList.add('active');
                } else {
                    voiceVisualizer.classList.remove('active');
                }
            };

            continuousRecognition.onerror = function(event) {
                if (event.error !== 'no-speech') {
                    updateDebug(`è¿ç»­è¯†åˆ«é”™è¯¯: ${event.error}`);
                }

                // è‡ªåŠ¨é‡å¯è¯†åˆ«
                if (isInCall && event.error !== 'aborted') {
                    setTimeout(() => {
                        if (isInCall) {
                            try {
                                continuousRecognition.start();
                                updateDebug('è‡ªåŠ¨é‡å¯è¯­éŸ³è¯†åˆ«');
                            } catch (e) {
                                updateDebug(`é‡å¯å¤±è´¥: ${e.message}`);
                            }
                        }
                    }, 500);
                }
            };

            continuousRecognition.onend = function() {
                updateDebug('è¿ç»­è¯†åˆ«ç»“æŸ');

                // å¦‚æœè¿˜åœ¨é€šè¯ä¸­ï¼Œå¿«é€Ÿé‡å¯
                if (isInCall) {
                    setTimeout(() => {
                        if (isInCall) {
                            try {
                                continuousRecognition.start();
                                updateDebug('é‡å¯è¿ç»­è¯†åˆ«');
                            } catch (e) {
                                updateDebug(`é‡å¯è¯†åˆ«å¤±è´¥: ${e.message}`);
                            }
                        }
                    }, 100);
                }
            };

            try {
                continuousRecognition.start();
                updateDebug('è¿ç»­è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
                voiceStatus.textContent = 'æ­£åœ¨å¬å–...';
            } catch (e) {
                updateDebug(`å¯åŠ¨è¿ç»­è¯†åˆ«å¤±è´¥: ${e.message}`);
            }
        }

        // è°ƒè¯•ä¿¡æ¯è¾“å‡º
        function updateDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            debugInfo.innerHTML = logEntry + '<br>' + (debugInfo.innerHTML || '');
            console.log(`[Voice Debug] ${message}`);

            // é™åˆ¶è°ƒè¯•ä¿¡æ¯é•¿åº¦
            const lines = debugInfo.innerHTML.split('<br>');
            if (lines.length > 15) {
                debugInfo.innerHTML = lines.slice(0, 15).join('<br>');
            }
        }

        // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
        function checkBrowserCompatibility() {
            updateDebug('æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§...');

            const userAgent = navigator.userAgent;
            const isChrome = userAgent.indexOf('Chrome') > -1;
            const isFirefox = userAgent.indexOf('Firefox') > -1;
            const isEdge = userAgent.indexOf('Edge') > -1;
            const isSafari = userAgent.indexOf('Safari') > -1 && userAgent.indexOf('Chrome') === -1;

            updateDebug(`æµè§ˆå™¨: ${isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isEdge ? 'Edge' : isSafari ? 'Safari' : 'æœªçŸ¥'}`);

            // æ£€æŸ¥å¿…è¦çš„APIæ”¯æŒ
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasSpeechRecognition = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
            const hasSpeechSynthesis = !!window.speechSynthesis;
            const hasWebSocket = !!window.WebSocket;
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

            updateDebug(`getUserMediaæ”¯æŒ: ${hasGetUserMedia}`);
            updateDebug(`è¯­éŸ³è¯†åˆ«æ”¯æŒ: ${hasSpeechRecognition}`);
            updateDebug(`è¯­éŸ³åˆæˆæ”¯æŒ: ${hasSpeechSynthesis}`);
            updateDebug(`WebSocketæ”¯æŒ: ${hasWebSocket}`);
            updateDebug(`å®‰å…¨ä¸Šä¸‹æ–‡: ${isSecureContext}`);

            let browserMessage = '';
            let canUseVoice = true;

            if (!hasGetUserMedia) {
                canUseVoice = false;
                browserMessage = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®åŠŸèƒ½ã€‚å»ºè®®ä½¿ç”¨æœ€æ–°ç‰ˆChromeæˆ–Edgeæµè§ˆå™¨ã€‚';
                updateDebug('æµè§ˆå™¨ä¸æ”¯æŒgetUserMedia API');
            } else if (!isSecureContext) {
                canUseVoice = false;
                browserMessage = 'è¯­éŸ³åŠŸèƒ½éœ€è¦åœ¨å®‰å…¨ç¯å¢ƒä¸‹ä½¿ç”¨ï¼ˆHTTPSã€localhostï¼‰ã€‚è¯·ç¡®ä¿ç½‘é¡µåœ°å€ä»¥https://å¼€å¤´ã€‚';
                updateDebug('éå®‰å…¨ä¸Šä¸‹æ–‡ï¼ŒæŸäº›æµè§ˆå™¨å¯èƒ½é™åˆ¶éº¦å…‹é£è®¿é—®');
            } else if (!hasSpeechRecognition) {
                canUseVoice = false;
                browserMessage = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½ã€‚å»ºè®®ä½¿ç”¨Chromeæµè§ˆå™¨ä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚';
                updateDebug('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«API');
            } else if (isSafari) {
                browserMessage = 'Safariæµè§ˆå™¨å¯¹è¯­éŸ³åŠŸèƒ½æ”¯æŒæœ‰é™ï¼Œå»ºè®®ä½¿ç”¨Chromeæµè§ˆå™¨ä»¥è·å¾—æ›´å¥½ä½“éªŒã€‚';
                updateDebug('Safariæµè§ˆå™¨ï¼ŒåŠŸèƒ½å¯èƒ½å—é™');
            }

            if (browserMessage) {
                browserInfo.textContent = browserMessage;
                browserInfo.style.display = 'block';
            }

            return canUseVoice;
        }

        // æ¿€æ´»è¯­éŸ³åŠŸèƒ½
        function activateVoiceFeatures() {
            updateDebug('æ¿€æ´»è¯­éŸ³åŠŸèƒ½...');

            // é€šè¿‡åˆ›å»ºä¸€ä¸ªç©ºçš„è¯­éŸ³æ’­æ”¾æ¥æ¿€æ´»éŸ³é¢‘ä¸Šä¸‹æ–‡
            const testUtterance = new SpeechSynthesisUtterance('');
            testUtterance.volume = 0;
            synthesis.speak(testUtterance);

            voiceActivated = true;
            activateBtn.style.display = 'none';
            activationNotice.style.display = 'none';

            voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½å·²æ¿€æ´»';
            voiceStatus.classList.add('success');

            updateDebug('è¯­éŸ³åŠŸèƒ½æ¿€æ´»æˆåŠŸ');
        }

        // å…¼å®¹æ€§æ›´å¥½çš„éº¦å…‹é£æƒé™æ£€æŸ¥
        async function checkMicrophonePermission() {
            updateDebug('æ£€æŸ¥éº¦å…‹é£æƒé™...');

            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰navigator.mediaDevices
                if (!navigator.mediaDevices) {
                    updateDebug('navigator.mediaDevices ä¸å¯ç”¨');

                    // å°è¯•æ—§ç‰ˆAPI
                    if (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) {
                        updateDebug('ä½¿ç”¨æ—§ç‰ˆgetUserMedia API');
                        return await requestMicrophoneAccessLegacy();
                    } else {
                        updateDebug('æ²¡æœ‰å¯ç”¨çš„getUserMedia API');
                        return false;
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰getUserMediaæ–¹æ³•
                if (!navigator.mediaDevices.getUserMedia) {
                    updateDebug('navigator.mediaDevices.getUserMedia ä¸å¯ç”¨');
                    return false;
                }

                // ç°ä»£æµè§ˆå™¨æƒé™æ£€æŸ¥
                if (navigator.permissions) {
                    const permission = await navigator.permissions.query({ name: 'microphone' });
                    updateDebug(`æƒé™çŠ¶æ€: ${permission.state}`);

                    if (permission.state === 'granted') {
                        return true;
                    } else if (permission.state === 'denied') {
                        return false;
                    }
                }

                // ç›´æ¥å°è¯•è·å–åª’ä½“è®¿é—®
                return await requestMicrophoneAccess();

            } catch (error) {
                updateDebug(`æƒé™æ£€æŸ¥å¤±è´¥: ${error.name} - ${error.message}`);
                return false;
            }
        }

        // ç°ä»£APIè¯·æ±‚éº¦å…‹é£è®¿é—®
        async function requestMicrophoneAccess() {
            updateDebug('è¯·æ±‚éº¦å…‹é£è®¿é—® (ç°ä»£API)...');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                updateDebug('éº¦å…‹é£è®¿é—®æˆåŠŸ');

                // ç«‹å³åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                return true;

            } catch (error) {
                updateDebug(`éº¦å…‹é£è®¿é—®å¤±è´¥: ${error.name} - ${error.message}`);

                if (error.name === 'NotAllowedError') {
                    voiceStatus.textContent = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»';
                    voiceStatus.classList.add('error');
                } else if (error.name === 'NotFoundError') {
                    voiceStatus.textContent = 'æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡';
                    voiceStatus.classList.add('error');
                } else if (error.name === 'NotSupportedError') {
                    voiceStatus.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®';
                    voiceStatus.classList.add('error');
                } else {
                    voiceStatus.textContent = 'éº¦å…‹é£è®¿é—®å¤±è´¥';
                    voiceStatus.classList.add('error');
                }

                return false;
            }
        }

        // æ—§ç‰ˆAPIè¯·æ±‚éº¦å…‹é£è®¿é—®
        async function requestMicrophoneAccessLegacy() {
            updateDebug('è¯·æ±‚éº¦å…‹é£è®¿é—® (æ—§ç‰ˆAPI)...');

            return new Promise((resolve) => {
                const getUserMedia = navigator.getUserMedia ||
                                  navigator.webkitGetUserMedia ||
                                  navigator.mozGetUserMedia;

                if (!getUserMedia) {
                    updateDebug('æ²¡æœ‰å¯ç”¨çš„getUserMediaå‡½æ•°');
                    resolve(false);
                    return;
                }

                getUserMedia.call(navigator,
                    { audio: true },
                    function(stream) {
                        updateDebug('éº¦å…‹é£è®¿é—®æˆåŠŸ (æ—§ç‰ˆAPI)');
                        stream.getTracks().forEach(track => track.stop());
                        resolve(true);
                    },
                    function(error) {
                        updateDebug(`éº¦å…‹é£è®¿é—®å¤±è´¥ (æ—§ç‰ˆAPI): ${error.name}`);
                        resolve(false);
                    }
                );
            });
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            updateDebug('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');

            // åˆå§‹åŒ–WebSocket
            initializeWebSocket();

            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            const isCompatible = checkBrowserCompatibility();

            if (!isCompatible) {
                voiceStatus.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½';
                voiceStatus.classList.add('error');
                recordBtn.disabled = true;
                updateDebug('æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥å¤±è´¥ï¼Œç¦ç”¨è¯­éŸ³åŠŸèƒ½');
            } else {
                // æ˜¾ç¤ºæ¿€æ´»æç¤º
                activationNotice.style.display = 'block';
                activateBtn.style.display = 'inline-block';
                voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';

                // æ£€æŸ¥æƒé™
                const hasPermission = await checkMicrophonePermission();

                if (hasPermission) {
                    initializeVoice();
                } else {
                    voiceStatus.textContent = 'éœ€è¦éº¦å…‹é£æƒé™';
                    voiceStatus.classList.add('error');
                    recordBtn.disabled = true;
                }
            }

            loadChatHistory();
            initializeEventListeners();
            loadVoiceConfig();
        });

        // åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½
        function initializeVoice() {
            updateDebug('åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½...');

            try {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = langSelect.value;
                recognition.maxAlternatives = 1;

                recognition.onstart = function() {
                    updateDebug('è¯­éŸ³è¯†åˆ«å¼€å§‹');
                    voiceStatus.textContent = 'æ­£åœ¨å¬å–è¯­éŸ³...';
                    voiceStatus.classList.remove('error', 'success');
                    voiceStatus.classList.add('recording');
                };

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    const confidence = event.results[0][0].confidence;
                    updateDebug(`è¯†åˆ«ç»“æœ: "${transcript}" (ç½®ä¿¡åº¦: ${confidence.toFixed(2)})`);
                    handleVoiceInput(transcript);
                };

                recognition.onerror = function(event) {
                    updateDebug(`è¯­éŸ³è¯†åˆ«é”™è¯¯: ${event.error}`);
                    voiceStatus.textContent = `è¯†åˆ«é”™è¯¯: ${event.error}`;
                    voiceStatus.classList.add('error');
                    resetRecordingState();
                };

                recognition.onend = function() {
                    updateDebug('è¯­éŸ³è¯†åˆ«ç»“æŸ');
                    resetRecordingState();
                };

                if (voiceActivated) {
                    voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½å‡†å¤‡å°±ç»ª';
                    voiceStatus.classList.remove('error');
                    voiceStatus.classList.add('success');
                } else {
                    voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';
                }

                updateDebug('è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–æˆåŠŸ');
                recordBtn.disabled = !voiceInput.checked;

            } catch (error) {
                updateDebug(`è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥';
                voiceStatus.classList.add('error');
                recordBtn.disabled = true;
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            updateDebug('åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨...');

            // æ¿€æ´»æŒ‰é’®
            activateBtn.addEventListener('click', activateVoiceFeatures);

            // å‘é€æŒ‰é’®
            sendBtn.addEventListener('click', sendMessage);

            // å›è½¦å‘é€
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // å½•éŸ³æŒ‰é’®äº‹ä»¶
            recordBtn.addEventListener('mousedown', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡æŒ‰ä¸‹å½•éŸ³æŒ‰é’®');
                startRecordingWithDelay();
            });

            recordBtn.addEventListener('mouseup', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡é‡Šæ”¾å½•éŸ³æŒ‰é’®');
                stopRecording();
            });

            recordBtn.addEventListener('mouseleave', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡ç¦»å¼€å½•éŸ³æŒ‰é’®');
                stopRecording();
            });

            // æ’­æ”¾æŒ‰é’®
            playBtn.addEventListener('click', playLastResponse);

            // è¯­è¨€é€‰æ‹©
            langSelect.addEventListener('change', function() {
                if (recognition) {
                    recognition.lang = langSelect.value;
                    updateDebug(`è¯­è¨€åˆ‡æ¢ä¸º: ${langSelect.value}`);
                }
            });

            // è¯­éŸ³è¾“å…¥å¼€å…³
            voiceInput.addEventListener('change', function() {
                if (this.checked && recognition) {
                    recordBtn.disabled = false;
                } else {
                    recordBtn.disabled = true;
                }
                updateDebug(`è¯­éŸ³è¾“å…¥${this.checked ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
            });

            // é€šè¯æŒ‰é’®
            startCallBtn.addEventListener('click', startVoiceCall);
            endCallBtn.addEventListener('click', endVoiceCall);

            updateDebug('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');
        }

        // å¸¦å»¶è¿Ÿçš„å½•éŸ³å¼€å§‹
        function startRecordingWithDelay() {
            if (mouseDownTimer) {
                clearTimeout(mouseDownTimer);
            }

            mouseDownTimer = setTimeout(() => {
                if (!isRecording && recognition && !isInCall) {
                    startRecording();
                }
            }, 150);
        }

        // å¼€å§‹å½•éŸ³
        function startRecording() {
            if (isRecording || !voiceInput.checked || !recognition || isInCall) {
                updateDebug('å½•éŸ³å¼€å§‹è¢«å¿½ç•¥');
                return;
            }

            updateDebug('å¼€å§‹å½•éŸ³...');
            isRecording = true;
            recordingStartTime = Date.now();
            recordBtn.textContent = 'ğŸ”´ å½•éŸ³ä¸­...';
            recordBtn.classList.add('recording');

            try {
                recognition.start();
            } catch (error) {
                updateDebug(`å¯åŠ¨å½•éŸ³å¤±è´¥: ${error.message}`);
                resetRecordingState();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (mouseDownTimer) {
                clearTimeout(mouseDownTimer);
                mouseDownTimer = null;
            }

            if (!isRecording) {
                return;
            }

            const recordingDuration = Date.now() - recordingStartTime;
            updateDebug(`åœæ­¢å½•éŸ³ï¼ŒæŒç»­æ—¶é—´: ${recordingDuration}ms`);

            isRecording = false;

            if (recognition) {
                try {
                    recognition.stop();
                } catch (error) {
                    updateDebug(`åœæ­¢å½•éŸ³å¤±è´¥: ${error.message}`);
                }
            }

            voiceStatus.textContent = 'å¤„ç†ä¸­...';
            voiceStatus.classList.add('processing');
        }

        // é‡ç½®å½•éŸ³çŠ¶æ€
        function resetRecordingState() {
            isRecording = false;
            recordBtn.textContent = 'ğŸ¤ é•¿æŒ‰è¯´è¯';
            recordBtn.classList.remove('recording');
            voiceStatus.classList.remove('recording', 'processing', 'error');

            if (recognition && voiceInput.checked && voiceActivated) {
                voiceStatus.textContent = 'å‡†å¤‡å°±ç»ª';
                voiceStatus.classList.add('success');
            } else if (!voiceActivated) {
                voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';
            } else {
                voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½æœªå°±ç»ª';
            }
        }

        // å¤„ç†è¯­éŸ³è¾“å…¥
        async function handleVoiceInput(transcript) {
            updateDebug(`å¤„ç†è¯­éŸ³è¾“å…¥: "${transcript}"`);
            voiceStatus.textContent = `è¯†åˆ«åˆ°: ${transcript}`;
            messageInput.value = transcript;

            setTimeout(async () => {
                await sendMessage();
                setTimeout(resetRecordingState, 1000);
            }, 500);
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            displayMessage('user', message);
            messageInput.value = '';

            // å¦‚æœä¸åœ¨é€šè¯ä¸­ï¼Œæ˜¾ç¤ºè¾“å…¥æŒ‡ç¤ºå™¨
            if (!isInCall) {
                showTypingIndicator();
            }

            try {
                const response = await fetch('/api/chat/voice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: message,
                        use_voice_response: true
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (!isInCall) {
                    hideTypingIndicator();
                    displayMessage('assistant', data.response);
                    lastResponse = data.response;

                    // ç«‹å³æ’­æ”¾å“åº”ï¼ˆå¦‚æœå·²æ¿€æ´»ä¸”è‡ªåŠ¨æ’­æ”¾å¼€å¯ï¼‰
                    if (autoPlay.checked && voiceActivated && !isInCall) {
                        updateDebug('è‡ªåŠ¨æ’­æ”¾AIå›å¤');
                        speakText(data.response);
                    } else {
                        playBtn.disabled = false;
                        if (!voiceActivated) {
                            updateDebug('è¯­éŸ³æœªæ¿€æ´»ï¼Œæ— æ³•è‡ªåŠ¨æ’­æ”¾');
                        }
                    }
                }

            } catch (error) {
                hideTypingIndicator();
                displayMessage('assistant', 'æŠ±æ­‰ï¼Œå‡ºç°äº†é”™è¯¯ï¼Œè¯·ç¨åå†è¯•ã€‚');
                updateDebug(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function displayMessage(sender, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;

            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // æ˜¾ç¤º/éšè—è¾“å…¥æŒ‡ç¤ºå™¨
        function showTypingIndicator() {
            typingIndicator.style.display = 'block';
        }

        function hideTypingIndicator() {
            typingIndicator.style.display = 'none';
        }

        // è¯­éŸ³æ’­æ”¾ - æ”¹è¿›ç‰ˆæœ¬
        function speakText(text) {
            updateDebug(`å¼€å§‹æ’­æ”¾æ–‡æœ¬: "${text.substring(0, 50)}..."`);
            // åœæ­¢å½“å‰æ’­æ”¾
            synthesis.cancel();

            if (currentUtterance) {
                currentUtterance = null;
            }

            currentUtterance = new SpeechSynthesisUtterance(text);

            // è®¾ç½®è¯­éŸ³å‚æ•°
            currentUtterance.lang = langSelect.value;
            currentUtterance.rate = 0.9;
            currentUtterance.pitch = 1.0;
            currentUtterance.volume = 1.0;

            currentUtterance.onstart = function() {
                updateDebug('è¯­éŸ³æ’­æ”¾å¼€å§‹');
                voiceStatus.textContent = 'æ­£åœ¨æ’­æ”¾å›å¤...';
                voiceStatus.classList.remove('error', 'success', 'recording', 'processing');
                voiceStatus.classList.add('speaking');
                playBtn.textContent = 'â¹ï¸ åœæ­¢';
                playBtn.disabled = false;
            };

            currentUtterance.onend = function() {
                updateDebug('è¯­éŸ³æ’­æ”¾ç»“æŸ');
                voiceStatus.textContent = 'æ’­æ”¾å®Œæˆ';
                voiceStatus.classList.remove('speaking');
                voiceStatus.classList.add('success');
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                currentUtterance = null;

                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    if (voiceActivated) {
                        resetRecordingState();
                    }
                }, 3000);
            };

            currentUtterance.onerror = function(event) {
                updateDebug(`è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`);
                voiceStatus.textContent = 'æ’­æ”¾å¤±è´¥';
                voiceStatus.classList.remove('speaking');
                voiceStatus.classList.add('error');
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                currentUtterance = null;
            };

            // å¼€å§‹æ’­æ”¾
            try {
                synthesis.speak(currentUtterance);
                updateDebug('è¯­éŸ³æ’­æ”¾å‘½ä»¤å·²å‘é€');
            } catch (error) {
                updateDebug(`è¯­éŸ³æ’­æ”¾å¤±è´¥: ${error.message}`);
                voiceStatus.textContent = 'æ’­æ”¾å¤±è´¥';
                voiceStatus.classList.add('error');
            }
        }

        // æ’­æ”¾æœ€åå›å¤
        function playLastResponse() {
            if (synthesis.speaking || currentUtterance) {
                updateDebug('åœæ­¢å½“å‰æ’­æ”¾');
                synthesis.cancel();
                currentUtterance = null;
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                voiceStatus.textContent = 'æ’­æ”¾å·²åœæ­¢';
                voiceStatus.classList.remove('speaking');
            } else if (lastResponse) {
                updateDebug('æ’­æ”¾æœ€åå›å¤');
                speakText(lastResponse);
            } else {
                updateDebug('æ²¡æœ‰å¯æ’­æ”¾çš„å›å¤');
                voiceStatus.textContent = 'æ²¡æœ‰å¯æ’­æ”¾çš„å†…å®¹';
            }
        }

        // åŠ è½½è¯­éŸ³é…ç½®å’ŒèŠå¤©å†å²
        async function loadVoiceConfig() {
            try {
                const response = await fetch(`/api/voice/config/${characterId}`);
                const data = await response.json();
                if (data.success) {
                    voiceConfig = data.config;
                    updateDebug('è¯­éŸ³é…ç½®åŠ è½½æˆåŠŸ');
                } else {
                    updateDebug('è¯­éŸ³é…ç½®åŠ è½½å¤±è´¥');
                }
            } catch (error) {
                updateDebug(`åŠ è½½è¯­éŸ³é…ç½®å¤±è´¥: ${error.message}`);
            }
        }

        async function loadChatHistory() {
            try {
                const response = await fetch(`/api/chat/history/${sessionId}`);
                const messages = await response.json();

                messages.forEach(msg => {
                    displayMessage(msg.sender_type, msg.content);
                });

                const lastAIMessage = messages.filter(m => m.sender_type === 'character').pop();
                if (lastAIMessage) {
                    lastResponse = lastAIMessage.content;
                    playBtn.disabled = false;
                }

                updateDebug(`åŠ è½½äº†${messages.length}æ¡å†å²æ¶ˆæ¯`);
            } catch (error) {
                updateDebug(`åŠ è½½èŠå¤©å†å²å¤±è´¥: ${error.message}`);
            }
        }
    </script>
</body>
</html>
