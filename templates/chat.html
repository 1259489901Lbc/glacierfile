<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ character.name }} - AIè§’è‰²èŠå¤©</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .chat-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .character-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .character-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
        }
        
        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message.assistant {
            justify-content: flex-start;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        
        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .message.assistant .message-content {
            background: white;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .voice-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            user-select: none;
        }

        .record-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            min-width: 140px;
        }

        .record-btn:hover:not(.recording):not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .record-btn.recording {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            animation: pulse 1s infinite;
            transform: scale(1.05);
        }

        .record-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .play-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            min-width: 100px;
        }

        .play-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }

        .play-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .activate-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            min-width: 120px;
            display: none;
        }

        .activate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
        }

        @keyframes pulse {
            0% { transform: scale(1.05); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1.05); }
        }

        .voice-status {
            flex: 1;
            font-size: 14px;
            color: #666;
            margin-left: 10px;
            font-weight: 500;
        }

        .voice-status.recording {
            color: #f44336;
            font-weight: bold;
        }

        .voice-status.processing {
            color: #ff9800;
        }

        .voice-status.error {
            color: #f44336;
        }

        .voice-status.success {
            color: #4CAF50;
        }

        .voice-status.speaking {
            color: #2196F3;
            font-weight: bold;
        }

        .voice-settings {
            display: flex;
            gap: 15px;
            font-size: 12px;
            align-items: center;
        }

        .voice-settings label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            white-space: nowrap;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            outline: none;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            color: #666;
            font-style: italic;
        }

        .debug-info {
            font-size: 11px;
            color: #999;
            margin: 0 20px 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            border: 1px solid #dee2e6;
            max-height: 80px;
            overflow-y: auto;
        }

        .browser-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 12px;
            margin: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
        }

        .activation-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            margin: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <!-- èŠå¤©å¤´éƒ¨ -->
        <div class="chat-header">
            <div class="character-info">
                <img src="{{ character.avatar }}" alt="{{ character.name }}" class="character-avatar">
                <div>
                    <h2 style="margin: 0;">{{ character.name }}</h2>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">{{ character.description }}</p>
                </div>
            </div>
        </div>

        <!-- æµè§ˆå™¨å…¼å®¹æ€§æç¤º -->
        <div class="browser-info" id="browserInfo" style="display: none;">
        </div>

        <!-- æ¿€æ´»æç¤º -->
        <div class="activation-notice" id="activationNotice" style="display: none;">
            <strong>ğŸ”Š è¯­éŸ³åŠŸèƒ½éœ€è¦æ¿€æ´»</strong><br>
            è¯·ç‚¹å‡»ä¸‹æ–¹çš„"æ¿€æ´»è¯­éŸ³"æŒ‰é’®ä»¥å¯ç”¨è‡ªåŠ¨è¯­éŸ³å›å¤åŠŸèƒ½
        </div>

        <!-- è¯­éŸ³æ§åˆ¶ -->
        <div class="voice-controls">
            <button id="activateBtn" class="voice-btn activate-btn">ğŸ”Š æ¿€æ´»è¯­éŸ³</button>
            <button id="recordBtn" class="voice-btn record-btn">ğŸ¤ é•¿æŒ‰è¯´è¯</button>
            <button id="playBtn" class="voice-btn play-btn" disabled>ğŸ”Š æ’­æ”¾</button>
            <div class="voice-status" id="voiceStatus">æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§...</div>
            <div class="voice-settings">
                <label>
                    <input type="checkbox" id="autoPlay" checked> è‡ªåŠ¨æ’­æ”¾
                </label>
                <label>
                    <input type="checkbox" id="voiceInput" checked> è¯­éŸ³è¾“å…¥
                </label>
                <select id="langSelect">
                    <option value="zh-CN">ä¸­æ–‡</option>
                    <option value="en-US">English</option>
                    <option value="ja-JP">æ—¥æœ¬èª</option>
                </select>
            </div>
        </div>

        <!-- è°ƒè¯•ä¿¡æ¯ -->
        <div class="debug-info" id="debugInfo"></div>

        <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ -->
        <div class="chat-messages" id="chatMessages">
            <!-- æ¶ˆæ¯å°†åœ¨è¿™é‡ŒåŠ¨æ€æ˜¾ç¤º -->
        </div>

        <div class="typing-indicator" id="typingIndicator">
            {{ character.name }} æ­£åœ¨è¾“å…¥...
        </div>

        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="chat-input">
            <div class="input-group">
                <input
                    type="text"
                    id="messageInput"
                    class="message-input"
                    placeholder="è¾“å…¥æ¶ˆæ¯æˆ–é•¿æŒ‰è¯­éŸ³æŒ‰é’®è¯´è¯..."
                    maxlength="2000"
                >
                <button id="sendBtn" class="send-btn">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const sessionId = '{{ session_id }}';
        const characterId = '{{ character.id }}';
        let voiceConfig = null;
        let lastResponse = '';
        let isRecording = false;
        let recognition = null;
        let synthesis = window.speechSynthesis;
        let recordingStartTime = 0;
        let mouseDownTimer = null;
        let voiceActivated = false;
        let currentUtterance = null;

        // DOMå…ƒç´ 
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const typingIndicator = document.getElementById('typingIndicator');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const activateBtn = document.getElementById('activateBtn');
        const voiceStatus = document.getElementById('voiceStatus');
        const autoPlay = document.getElementById('autoPlay');
        const voiceInput = document.getElementById('voiceInput');
        const langSelect = document.getElementById('langSelect');
        const debugInfo = document.getElementById('debugInfo');
        const browserInfo = document.getElementById('browserInfo');
        const activationNotice = document.getElementById('activationNotice');

        // è°ƒè¯•ä¿¡æ¯è¾“å‡º
        function updateDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            debugInfo.innerHTML = logEntry + '<br>' + (debugInfo.innerHTML || '');
            console.log(`[Voice Debug] ${message}`);

            // é™åˆ¶è°ƒè¯•ä¿¡æ¯é•¿åº¦
            const lines = debugInfo.innerHTML.split('<br>');
            if (lines.length > 15) {
                debugInfo.innerHTML = lines.slice(0, 15).join('<br>');
            }
        }

        // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
        function checkBrowserCompatibility() {
            updateDebug('æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§...');

            const userAgent = navigator.userAgent;
            const isChrome = userAgent.indexOf('Chrome') > -1;
            const isFirefox = userAgent.indexOf('Firefox') > -1;
            const isEdge = userAgent.indexOf('Edge') > -1;
            const isSafari = userAgent.indexOf('Safari') > -1 && userAgent.indexOf('Chrome') === -1;

            updateDebug(`æµè§ˆå™¨: ${isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isEdge ? 'Edge' : isSafari ? 'Safari' : 'æœªçŸ¥'}`);

            // æ£€æŸ¥å¿…è¦çš„APIæ”¯æŒ
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasSpeechRecognition = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
            const hasSpeechSynthesis = !!window.speechSynthesis;
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

            updateDebug(`getUserMediaæ”¯æŒ: ${hasGetUserMedia}`);
            updateDebug(`è¯­éŸ³è¯†åˆ«æ”¯æŒ: ${hasSpeechRecognition}`);
            updateDebug(`è¯­éŸ³åˆæˆæ”¯æŒ: ${hasSpeechSynthesis}`);
            updateDebug(`å®‰å…¨ä¸Šä¸‹æ–‡: ${isSecureContext}`);

            let browserMessage = '';
            let canUseVoice = true;

            if (!hasGetUserMedia) {
                canUseVoice = false;
                browserMessage = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®åŠŸèƒ½ã€‚å»ºè®®ä½¿ç”¨æœ€æ–°ç‰ˆChromeæˆ–Edgeæµè§ˆå™¨ã€‚';
                updateDebug('æµè§ˆå™¨ä¸æ”¯æŒgetUserMedia API');
            } else if (!isSecureContext) {
                canUseVoice = false;
                browserMessage = 'è¯­éŸ³åŠŸèƒ½éœ€è¦åœ¨å®‰å…¨ç¯å¢ƒä¸‹ä½¿ç”¨ï¼ˆHTTPSã€localhostï¼‰ã€‚è¯·ç¡®ä¿ç½‘é¡µåœ°å€ä»¥https://å¼€å¤´ã€‚';
                updateDebug('éå®‰å…¨ä¸Šä¸‹æ–‡ï¼ŒæŸäº›æµè§ˆå™¨å¯èƒ½é™åˆ¶éº¦å…‹é£è®¿é—®');
            } else if (!hasSpeechRecognition) {
                canUseVoice = false;
                browserMessage = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½ã€‚å»ºè®®ä½¿ç”¨Chromeæµè§ˆå™¨ä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚';
                updateDebug('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«API');
            } else if (isSafari) {
                browserMessage = 'Safariæµè§ˆå™¨å¯¹è¯­éŸ³åŠŸèƒ½æ”¯æŒæœ‰é™ï¼Œå»ºè®®ä½¿ç”¨Chromeæµè§ˆå™¨ä»¥è·å¾—æ›´å¥½ä½“éªŒã€‚';
                updateDebug('Safariæµè§ˆå™¨ï¼ŒåŠŸèƒ½å¯èƒ½å—é™');
            }

            if (browserMessage) {
                browserInfo.textContent = browserMessage;
                browserInfo.style.display = 'block';
            }

            return canUseVoice;
        }

        // æ¿€æ´»è¯­éŸ³åŠŸèƒ½
        function activateVoiceFeatures() {
            updateDebug('æ¿€æ´»è¯­éŸ³åŠŸèƒ½...');

            // é€šè¿‡åˆ›å»ºä¸€ä¸ªç©ºçš„è¯­éŸ³æ’­æ”¾æ¥æ¿€æ´»éŸ³é¢‘ä¸Šä¸‹æ–‡
            const testUtterance = new SpeechSynthesisUtterance('');
            testUtterance.volume = 0;
            synthesis.speak(testUtterance);

            voiceActivated = true;
            activateBtn.style.display = 'none';
            activationNotice.style.display = 'none';

            voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½å·²æ¿€æ´»';
            voiceStatus.classList.add('success');

            updateDebug('è¯­éŸ³åŠŸèƒ½æ¿€æ´»æˆåŠŸ');
        }

        // å…¼å®¹æ€§æ›´å¥½çš„éº¦å…‹é£æƒé™æ£€æŸ¥
        async function checkMicrophonePermission() {
            updateDebug('æ£€æŸ¥éº¦å…‹é£æƒé™...');

            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰navigator.mediaDevices
                if (!navigator.mediaDevices) {
                    updateDebug('navigator.mediaDevices ä¸å¯ç”¨');

                    // å°è¯•æ—§ç‰ˆAPI
                    if (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) {
                        updateDebug('ä½¿ç”¨æ—§ç‰ˆgetUserMedia API');
                        return await requestMicrophoneAccessLegacy();
                    } else {
                        updateDebug('æ²¡æœ‰å¯ç”¨çš„getUserMedia API');
                        return false;
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰getUserMediaæ–¹æ³•
                if (!navigator.mediaDevices.getUserMedia) {
                    updateDebug('navigator.mediaDevices.getUserMedia ä¸å¯ç”¨');
                    return false;
                }

                // ç°ä»£æµè§ˆå™¨æƒé™æ£€æŸ¥
                if (navigator.permissions) {
                    const permission = await navigator.permissions.query({ name: 'microphone' });
                    updateDebug(`æƒé™çŠ¶æ€: ${permission.state}`);

                    if (permission.state === 'granted') {
                        return true;
                    } else if (permission.state === 'denied') {
                        return false;
                    }
                }

                // ç›´æ¥å°è¯•è·å–åª’ä½“è®¿é—®
                return await requestMicrophoneAccess();

            } catch (error) {
                updateDebug(`æƒé™æ£€æŸ¥å¤±è´¥: ${error.name} - ${error.message}`);
                return false;
            }
        }

        // ç°ä»£APIè¯·æ±‚éº¦å…‹é£è®¿é—®
        async function requestMicrophoneAccess() {
            updateDebug('è¯·æ±‚éº¦å…‹é£è®¿é—® (ç°ä»£API)...');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                updateDebug('éº¦å…‹é£è®¿é—®æˆåŠŸ');

                // ç«‹å³åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                return true;

            } catch (error) {
                updateDebug(`éº¦å…‹é£è®¿é—®å¤±è´¥: ${error.name} - ${error.message}`);

                if (error.name === 'NotAllowedError') {
                    voiceStatus.textContent = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»';
                    voiceStatus.classList.add('error');
                } else if (error.name === 'NotFoundError') {
                    voiceStatus.textContent = 'æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡';
                    voiceStatus.classList.add('error');
                } else if (error.name === 'NotSupportedError') {
                    voiceStatus.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®';
                    voiceStatus.classList.add('error');
                } else {
                    voiceStatus.textContent = 'éº¦å…‹é£è®¿é—®å¤±è´¥';
                    voiceStatus.classList.add('error');
                }

                return false;
            }
        }

        // æ—§ç‰ˆAPIè¯·æ±‚éº¦å…‹é£è®¿é—®
        async function requestMicrophoneAccessLegacy() {
            updateDebug('è¯·æ±‚éº¦å…‹é£è®¿é—® (æ—§ç‰ˆAPI)...');

            return new Promise((resolve) => {
                const getUserMedia = navigator.getUserMedia ||
                                  navigator.webkitGetUserMedia ||
                                  navigator.mozGetUserMedia;

                if (!getUserMedia) {
                    updateDebug('æ²¡æœ‰å¯ç”¨çš„getUserMediaå‡½æ•°');
                    resolve(false);
                    return;
                }

                getUserMedia.call(navigator,
                    { audio: true },
                    function(stream) {
                        updateDebug('éº¦å…‹é£è®¿é—®æˆåŠŸ (æ—§ç‰ˆAPI)');
                        stream.getTracks().forEach(track => track.stop());
                        resolve(true);
                    },
                    function(error) {
                        updateDebug(`éº¦å…‹é£è®¿é—®å¤±è´¥ (æ—§ç‰ˆAPI): ${error.name}`);
                        resolve(false);
                    }
                );
            });
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            updateDebug('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');

            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            const isCompatible = checkBrowserCompatibility();

            if (!isCompatible) {
                voiceStatus.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½';
                voiceStatus.classList.add('error');
                recordBtn.disabled = true;
                updateDebug('æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥å¤±è´¥ï¼Œç¦ç”¨è¯­éŸ³åŠŸèƒ½');
            } else {
                // æ˜¾ç¤ºæ¿€æ´»æç¤º
                activationNotice.style.display = 'block';
                activateBtn.style.display = 'inline-block';
                voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';

                // æ£€æŸ¥æƒé™
                const hasPermission = await checkMicrophonePermission();

                if (hasPermission) {
                    initializeVoice();
                } else {
                    voiceStatus.textContent = 'éœ€è¦éº¦å…‹é£æƒé™';
                    voiceStatus.classList.add('error');
                    recordBtn.disabled = true;
                }
            }

            loadChatHistory();
            initializeEventListeners();
            loadVoiceConfig();
        });

        // åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½
        function initializeVoice() {
            updateDebug('åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½...');

            try {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = langSelect.value;
                recognition.maxAlternatives = 1;

                recognition.onstart = function() {
                    updateDebug('è¯­éŸ³è¯†åˆ«å¼€å§‹');
                    voiceStatus.textContent = 'æ­£åœ¨å¬å–è¯­éŸ³...';
                    voiceStatus.classList.remove('error', 'success');
                    voiceStatus.classList.add('recording');
                };

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    const confidence = event.results[0][0].confidence;
                    updateDebug(`è¯†åˆ«ç»“æœ: "${transcript}" (ç½®ä¿¡åº¦: ${confidence.toFixed(2)})`);
                    handleVoiceInput(transcript);
                };

                recognition.onerror = function(event) {
                    updateDebug(`è¯­éŸ³è¯†åˆ«é”™è¯¯: ${event.error}`);
                    voiceStatus.textContent = `è¯†åˆ«é”™è¯¯: ${event.error}`;
                    voiceStatus.classList.add('error');
                    resetRecordingState();
                };

                recognition.onend = function() {
                    updateDebug('è¯­éŸ³è¯†åˆ«ç»“æŸ');
                    resetRecordingState();
                };

                if (voiceActivated) {
                    voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½å‡†å¤‡å°±ç»ª';
                    voiceStatus.classList.remove('error');
                    voiceStatus.classList.add('success');
                } else {
                    voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';
                }

                updateDebug('è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–æˆåŠŸ');
                recordBtn.disabled = !voiceInput.checked;

            } catch (error) {
                updateDebug(`è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥';
                voiceStatus.classList.add('error');
                recordBtn.disabled = true;
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            updateDebug('åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨...');

            // æ¿€æ´»æŒ‰é’®
            activateBtn.addEventListener('click', activateVoiceFeatures);

            // å‘é€æŒ‰é’®
            sendBtn.addEventListener('click', sendMessage);

            // å›è½¦å‘é€
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // å½•éŸ³æŒ‰é’®äº‹ä»¶
            recordBtn.addEventListener('mousedown', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡æŒ‰ä¸‹å½•éŸ³æŒ‰é’®');
                startRecordingWithDelay();
            });

            recordBtn.addEventListener('mouseup', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡é‡Šæ”¾å½•éŸ³æŒ‰é’®');
                stopRecording();
            });

            recordBtn.addEventListener('mouseleave', function(e) {
                e.preventDefault();
                updateDebug('é¼ æ ‡ç¦»å¼€å½•éŸ³æŒ‰é’®');
                stopRecording();
            });

            // æ’­æ”¾æŒ‰é’®
            playBtn.addEventListener('click', playLastResponse);

            // è¯­è¨€é€‰æ‹©
            langSelect.addEventListener('change', function() {
                if (recognition) {
                    recognition.lang = langSelect.value;
                    updateDebug(`è¯­è¨€åˆ‡æ¢ä¸º: ${langSelect.value}`);
                }
            });

            // è¯­éŸ³è¾“å…¥å¼€å…³
            voiceInput.addEventListener('change', function() {
                if (this.checked && recognition) {
                    recordBtn.disabled = false;
                } else {
                    recordBtn.disabled = true;
                }
                updateDebug(`è¯­éŸ³è¾“å…¥${this.checked ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
            });

            updateDebug('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');
        }

        // å¸¦å»¶è¿Ÿçš„å½•éŸ³å¼€å§‹
        function startRecordingWithDelay() {
            if (mouseDownTimer) {
                clearTimeout(mouseDownTimer);
            }

            mouseDownTimer = setTimeout(() => {
                if (!isRecording && recognition) {
                    startRecording();
                }
            }, 150);
        }

        // å¼€å§‹å½•éŸ³
        function startRecording() {
            if (isRecording || !voiceInput.checked || !recognition) {
                updateDebug('å½•éŸ³å¼€å§‹è¢«å¿½ç•¥');
                return;
            }

            updateDebug('å¼€å§‹å½•éŸ³...');
            isRecording = true;
            recordingStartTime = Date.now();
            recordBtn.textContent = 'ğŸ”´ å½•éŸ³ä¸­...';
            recordBtn.classList.add('recording');

            try {
                recognition.start();
            } catch (error) {
                updateDebug(`å¯åŠ¨å½•éŸ³å¤±è´¥: ${error.message}`);
                resetRecordingState();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (mouseDownTimer) {
                clearTimeout(mouseDownTimer);
                mouseDownTimer = null;
            }

            if (!isRecording) {
                return;
            }

            const recordingDuration = Date.now() - recordingStartTime;
            updateDebug(`åœæ­¢å½•éŸ³ï¼ŒæŒç»­æ—¶é—´: ${recordingDuration}ms`);

            isRecording = false;

            if (recognition) {
                try {
                    recognition.stop();
                } catch (error) {
                    updateDebug(`åœæ­¢å½•éŸ³å¤±è´¥: ${error.message}`);
                }
            }

            voiceStatus.textContent = 'å¤„ç†ä¸­...';
            voiceStatus.classList.add('processing');
        }

        // é‡ç½®å½•éŸ³çŠ¶æ€
        function resetRecordingState() {
            isRecording = false;
            recordBtn.textContent = 'ğŸ¤ é•¿æŒ‰è¯´è¯';
            recordBtn.classList.remove('recording');
            voiceStatus.classList.remove('recording', 'processing', 'error');

            if (recognition && voiceInput.checked && voiceActivated) {
                voiceStatus.textContent = 'å‡†å¤‡å°±ç»ª';
                voiceStatus.classList.add('success');
            } else if (!voiceActivated) {
                voiceStatus.textContent = 'éœ€è¦æ¿€æ´»è¯­éŸ³åŠŸèƒ½';
            } else {
                voiceStatus.textContent = 'è¯­éŸ³åŠŸèƒ½æœªå°±ç»ª';
            }
        }

        // å¤„ç†è¯­éŸ³è¾“å…¥
        async function handleVoiceInput(transcript) {
            updateDebug(`å¤„ç†è¯­éŸ³è¾“å…¥: "${transcript}"`);
            voiceStatus.textContent = `è¯†åˆ«åˆ°: ${transcript}`;
            messageInput.value = transcript;

            setTimeout(async () => {
                await sendMessage();
                setTimeout(resetRecordingState, 1000);
            }, 500);
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            displayMessage('user', message);
            messageInput.value = '';
            showTypingIndicator();

            try {
                const response = await fetch('/api/chat/voice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: message,
                        use_voice_response: true
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                hideTypingIndicator();
                displayMessage('assistant', data.response);
                lastResponse = data.response;

                // ç«‹å³æ’­æ”¾å“åº”ï¼ˆå¦‚æœå·²æ¿€æ´»ä¸”è‡ªåŠ¨æ’­æ”¾å¼€å¯ï¼‰
                if (autoPlay.checked && voiceActivated) {
                    updateDebug('è‡ªåŠ¨æ’­æ”¾AIå›å¤');
                    speakText(data.response);
                } else {
                    playBtn.disabled = false;
                    if (!voiceActivated) {
                        updateDebug('è¯­éŸ³æœªæ¿€æ´»ï¼Œæ— æ³•è‡ªåŠ¨æ’­æ”¾');
                    }
                }

            } catch (error) {
                hideTypingIndicator();
                displayMessage('assistant', 'æŠ±æ­‰ï¼Œå‡ºç°äº†é”™è¯¯ï¼Œè¯·ç¨åå†è¯•ã€‚');
                updateDebug(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function displayMessage(sender, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;

            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // æ˜¾ç¤º/éšè—è¾“å…¥æŒ‡ç¤ºå™¨
        function showTypingIndicator() {
            typingIndicator.style.display = 'block';
        }

        function hideTypingIndicator() {
            typingIndicator.style.display = 'none';
        }

        // è¯­éŸ³æ’­æ”¾ - æ”¹è¿›ç‰ˆæœ¬
        function speakText(text) {
            updateDebug(`å¼€å§‹æ’­æ”¾æ–‡æœ¬: "${text.substring(0, 50)}..."`);

            // åœæ­¢å½“å‰æ’­æ”¾
            synthesis.cancel();

            if (currentUtterance) {
                currentUtterance = null;
            }

            currentUtterance = new SpeechSynthesisUtterance(text);

            // è®¾ç½®è¯­éŸ³å‚æ•°
            currentUtterance.lang = langSelect.value;
            currentUtterance.rate = 0.9;
            currentUtterance.pitch = 1.0;
            currentUtterance.volume = 1.0;

            currentUtterance.onstart = function() {
                updateDebug('è¯­éŸ³æ’­æ”¾å¼€å§‹');
                voiceStatus.textContent = 'æ­£åœ¨æ’­æ”¾å›å¤...';
                voiceStatus.classList.remove('error', 'success', 'recording', 'processing');
                voiceStatus.classList.add('speaking');
                playBtn.textContent = 'â¹ï¸ åœæ­¢';
                playBtn.disabled = false;
            };

            currentUtterance.onend = function() {
                updateDebug('è¯­éŸ³æ’­æ”¾ç»“æŸ');
                voiceStatus.textContent = 'æ’­æ”¾å®Œæˆ';
                voiceStatus.classList.remove('speaking');
                voiceStatus.classList.add('success');
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                currentUtterance = null;

                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    if (voiceActivated) {
                        resetRecordingState();
                    }
                }, 3000);
            };

            currentUtterance.onerror = function(event) {
                updateDebug(`è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`);
                voiceStatus.textContent = 'æ’­æ”¾å¤±è´¥';
                voiceStatus.classList.remove('speaking');
                voiceStatus.classList.add('error');
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                currentUtterance = null;
            };

            // å¼€å§‹æ’­æ”¾
            try {
                synthesis.speak(currentUtterance);
                updateDebug('è¯­éŸ³æ’­æ”¾å‘½ä»¤å·²å‘é€');
            } catch (error) {
                updateDebug(`è¯­éŸ³æ’­æ”¾å¤±è´¥: ${error.message}`);
                voiceStatus.textContent = 'æ’­æ”¾å¤±è´¥';
                voiceStatus.classList.add('error');
            }
        }

        // æ’­æ”¾æœ€åå›å¤
        function playLastResponse() {
            if (synthesis.speaking || currentUtterance) {
                updateDebug('åœæ­¢å½“å‰æ’­æ”¾');
                synthesis.cancel();
                currentUtterance = null;
                playBtn.textContent = 'ğŸ”Š æ’­æ”¾';
                voiceStatus.textContent = 'æ’­æ”¾å·²åœæ­¢';
                voiceStatus.classList.remove('speaking');
            } else if (lastResponse) {
                updateDebug('æ’­æ”¾æœ€åå›å¤');
                speakText(lastResponse);
            } else {
                updateDebug('æ²¡æœ‰å¯æ’­æ”¾çš„å›å¤');
                voiceStatus.textContent = 'æ²¡æœ‰å¯æ’­æ”¾çš„å†…å®¹';
            }
        }

        // åŠ è½½è¯­éŸ³é…ç½®å’ŒèŠå¤©å†å²
        async function loadVoiceConfig() {
            try {
                const response = await fetch(`/api/voice/config/${characterId}`);
                const data = await response.json();
                if (data.success) {
                    voiceConfig = data.config;
                    updateDebug('è¯­éŸ³é…ç½®åŠ è½½æˆåŠŸ');
                } else {
                    updateDebug('è¯­éŸ³é…ç½®åŠ è½½å¤±è´¥');
                }
            } catch (error) {
                updateDebug(`åŠ è½½è¯­éŸ³é…ç½®å¤±è´¥: ${error.message}`);
            }
        }

        async function loadChatHistory() {
            try {
                const response = await fetch(`/api/chat/history/${sessionId}`);
                const messages = await response.json();

                messages.forEach(msg => {
                    displayMessage(msg.sender_type, msg.content);
                });

                const lastAIMessage = messages.filter(m => m.sender_type === 'character').pop();
                if (lastAIMessage) {
                    lastResponse = lastAIMessage.content;
                    playBtn.disabled = false;
                }

                updateDebug(`åŠ è½½äº†${messages.length}æ¡å†å²æ¶ˆæ¯`);
            } catch (error) {
                updateDebug(`åŠ è½½èŠå¤©å†å²å¤±è´¥: ${error.message}`);
            }
        }
    </script>
</body>
</html>